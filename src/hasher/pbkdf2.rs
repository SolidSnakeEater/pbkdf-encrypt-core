use crate::error;
use aes_gcm_siv::aead::OsRng;
use pbkdf2::{
    password_hash::{Ident, PasswordHasher, SaltString},
    Pbkdf2,
};
use sha2::Sha512;
use std::{fmt::Debug, marker::PhantomData};

// NOTE: This is the maximum key buffer size that can be generated by the PBKDF2 function.
pub const KEY_BUFF_SIZE: usize = 32;

pub enum Algorithm {
    Pbkdf2Sha512,
}

pub struct Hasher {}

impl Hasher {
    pub fn generate_hash(
        password: &str,
        salt_value: &str,
        rounds: &u32,
        override_salt: bool,
    ) -> error::Result<HasherResult>
where {
        // A salt for PBKDF2 (should be unique per encryption)
        let mut salt = SaltString::generate(&mut OsRng);

        if override_salt {
            salt = SaltString::from_b64(salt_value).expect("salt is base64 encoded");
        }

        // Derive a 32-byte key using PBKDF2 with SHA-512
        let algo = Ident::new("pbkdf2-sha512").expect("use SHA-512");
        let key = Pbkdf2
            .hash_password_customized(
                password.as_bytes(),
                Some(algo),
                None,
                pbkdf2::Params {
                    rounds: *rounds,
                    output_length: 32,
                },
                &salt,
            )
            .expect("32-byte key generated");

        // Convert the key to a fixed-size array
        let key_hash = key.hash.unwrap();
        let key_bytes = key_hash.as_bytes();
        let key_array: [u8; 32] = key_bytes.try_into().unwrap();
        let hash_hex = hex::encode(key_array);

        let result = HasherResult::new(hash_hex, salt.to_string());

        Ok(result)
    }
}

pub struct HasherResult {
    hash: String,
    salt: String,
}

impl HasherResult {
    pub fn new(hash: String, salt: String) -> Self {
        Self { hash, salt }
    }

    pub fn hash(&self) -> String {
        self.hash.to_string()
    }

    pub fn salt(&self) -> String {
        self.salt.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::Hasher;

    #[test]
    fn assert_32_byte_key_length() {
        const PBKDF_ROUNDS: u32 = 2;

        // NOTE: uses a static salt value for testing purposes
        let result = Hasher::generate_hash("password", "salt", &PBKDF_ROUNDS, true).unwrap();

        let decoded_hash = hex::decode(&result.hash).unwrap();
        assert_eq!(decoded_hash.len(), 32_usize);
        assert_eq!(
            &result.hash,
            &"8eb89352a0724cd4dfd8230e895c0ed0182574c37a1173b40489366cd0a78723".to_string()
        );
        assert_eq!(result.salt, "salt".to_string());
    }
}
