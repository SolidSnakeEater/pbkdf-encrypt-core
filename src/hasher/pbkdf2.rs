use crate::error;
use aes_gcm_siv::aead::OsRng;
use hmac::{digest::core_api::CoreWrapper, EagerHash, Hmac, HmacCore};
use pbkdf2::{
    password_hash::{Ident, PasswordHasher, SaltString},
    Pbkdf2,
};
use sha2::Sha512;
use std::{fmt::Debug, marker::PhantomData};

pub type PrfHasher = Sha512;

// NOTE: This is the maximum key buffer size that can be generated by the PBKDF2 function.
pub const KEY_BUFF_SIZE: usize = 32;

pub trait Hashable<H> {
    type KeyBuf;

    fn generate_hash(
        &mut self,
        password: &str,
        salt_value: &str,
        rounds: &u32,
        override_salt: bool,
    ) -> error::Result<HasherResult>;
}

#[derive(Debug)]
pub struct HashProvider<'a, H> {
    _hasher: PhantomData<H>,
    _buf: &'a mut Box<[u8; KEY_BUFF_SIZE]>,
}

impl<'a, H> HashProvider<'a, H> {
    pub fn new(buf: &'a mut Box<[u8; KEY_BUFF_SIZE]>) -> Self {
        Self {
            _hasher: PhantomData,
            _buf: buf,
        }
    }
}

impl<'a, H> Hashable<H> for HashProvider<'a, H> {
    type KeyBuf = [u8; KEY_BUFF_SIZE];

    // FIXME: remove salt argument from function signature
    fn generate_hash(
        &mut self,
        password: &str,
        salt_value: &str,
        rounds: &u32,
        override_salt: bool,
    ) -> error::Result<HasherResult>
where {
        // A salt for PBKDF2 (should be unique per encryption)
        let mut salt = SaltString::generate(&mut OsRng);

        if override_salt {
            salt = SaltString::from_b64(salt_value).expect("salt is base64 encoded");
        }

        // Derive a 32-byte key using PBKDF2 with SHA-512
        let algo = Ident::new("pbkdf2-sha512").expect("use SHA-512");
        let key = Pbkdf2
            .hash_password_customized(
                password.as_bytes(),
                Some(algo),
                None,
                pbkdf2::Params {
                    rounds: *rounds,
                    output_length: 32,
                },
                &salt,
            )
            .expect("32-byte key generated");

        // Convert the key to a fixed-size array
        let key_hash = key.hash.unwrap();
        let key_bytes = key_hash.as_bytes();
        let key_array: [u8; 32] = key_bytes.try_into().unwrap();
        let hash_hex = hex::encode(key_array);

        let result = HasherResult::new(hash_hex, salt.to_string());

        Ok(result)
    }
}

pub struct HasherResult {
    hash: String,
    salt: String,
}

impl HasherResult {
    pub fn new(hash: String, salt: String) -> Self {
        Self { hash, salt }
    }

    pub fn hash(&self) -> String {
        self.hash.to_string()
    }

    pub fn salt(&self) -> String {
        self.salt.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::Hashable;
    use super::{HashProvider, PrfHasher, KEY_BUFF_SIZE};

    #[test]
    fn assert_32_byte_key_length() {
        const PBKDF_ROUNDS: u32 = 2;
        let buf = [0u8; KEY_BUFF_SIZE];
        let mut buf_boxed = Box::new(buf);

        let hasher = &mut HashProvider::<PrfHasher>::new(&mut buf_boxed);

        // NOTE: uses a static salt value for testing purposes
        let result = hasher
            .generate_hash("password", "salt", &PBKDF_ROUNDS, true)
            .unwrap();

        let decoded_hash = hex::decode(&result.hash).unwrap();
        assert_eq!(decoded_hash.len(), 32_usize);
        assert_eq!(
            &result.hash,
            &"8eb89352a0724cd4dfd8230e895c0ed0182574c37a1173b40489366cd0a78723".to_string()
        );
        assert_eq!(result.salt, "salt".to_string());
    }
}
